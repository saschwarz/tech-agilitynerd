<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>tech.agilitynerd</title><link href="http://tech.agilitynerd.com/" rel="alternate"></link><link href="http://127.0.0.1:8000/feeds/tag.nginx.atom.xml" rel="self"></link><id>http://tech.agilitynerd.com/</id><updated>2016-09-04T12:02:00-05:00</updated><entry><title>NGINX, HTTPS, Let's Encrypt, and Django</title><link href="http://tech.agilitynerd.com/nginx-https-lets-encrypt-and-django.html" rel="alternate"></link><published>2016-09-04T12:02:00-05:00</published><author><name>Steve Schwarz</name></author><id>tag:tech.agilitynerd.com,2016-09-04:nginx-https-lets-encrypt-and-django.html</id><summary type="html">&lt;p&gt;My &lt;a class="reference external" href="https://agilitycourses.com"&gt;agilitycourses.com&lt;/a&gt; website is served by &lt;a class="reference external" href="https://nginx.org/en/"&gt;nginx&lt;/a&gt; proxying to &lt;a class="reference external" href="http://gunicorn.org/"&gt;gunicorn&lt;/a&gt; running my &lt;a class="reference external" href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; application. I'll be adding user accounts soon so I wanted to convert the site to be more secure by using HTTPS encryption. Also &lt;a class="reference external" href="https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html"&gt;Google has announced it will likely prefer sites using HTTPS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The site is running on Ubuntu 14.04 LTS. I won't recount the whole process, I followed some great resources and made a couple adjustments that might be helpful to others.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;I basically followed the instructions in this excellent Digital Ocean tutorial: &lt;a class="reference external" href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04"&gt;How To Secure Nginx with Let's Encrypt on Ubuntu 14.04&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I confirmed via the &lt;a class="reference external" href="https://www.ssllabs.com/ssltest/analyze.html"&gt;SSL Labs SSL Server Test&lt;/a&gt; that my IPv4 and IPv6 server configurations had &amp;quot;A+&amp;quot; ratings.&lt;/li&gt;
&lt;li&gt;While looking for other SSL testing sites I came across &lt;a class="reference external" href="https://securityheaders.io/"&gt;securityheaders.io&lt;/a&gt; developed by &lt;a class="reference external" href="https://scotthelme.co.uk/"&gt;Scott Helme&lt;/a&gt;. My initial score was a sad &amp;quot;D&amp;quot;. The site has snippets for NGINX and Apache configuration changes and in depth articles describing the how and the why.&lt;/li&gt;
&lt;li&gt;While investigating the changes to the HTTP Headers to improve my test score I came across this &lt;a class="reference external" href="https://github.com/jonnybarnes/nginx-conf"&gt;nginx-conf GitHub repository&lt;/a&gt;. Specifically the idea of putting the header settings into an &lt;a class="reference external" href="https://github.com/jonnybarnes/nginx-conf/blob/master/conf/includes/security-headers.conf"&gt;NGINX include file&lt;/a&gt;. I have several other domains on the same server and will also be converting them. I used that idea to include ssl and header configurations into any virtual host.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here's my &lt;cite&gt;/etc/nginx/ssl.conf&lt;/cite&gt; file:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# From https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_prefer_server_ciphers on;
ssl_dhparam /etc/ssl/certs/dhparam.pem;
ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA';
ssl_session_timeout 1d;
ssl_session_cache shared:SSL:50m;
ssl_stapling on;
ssl_stapling_verify on;
&lt;/pre&gt;
&lt;p&gt;And my &lt;cite&gt;/etc/nginx/security_headers.conf&lt;/cite&gt; file:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# See https://github.com/jonnybarnes/nginx-conf/blob/master/conf/includes/security-headers.conf
add_header X-Xss-Protection &amp;quot;1; mode=block&amp;quot;;
add_header X-Content-Type-Options &amp;quot;nosniff&amp;quot;;
add_header Content-Security-Policy &amp;quot;default-src https: data: 'unsafe-inline' 'unsafe-eval'&amp;quot;;
add_header Strict-Transport-Security max-age=15768000;
&lt;/pre&gt;
&lt;p&gt;So my server blocks with all these edits are now:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# redirect http://www.tld and http://tld to https://www.tld
server {
    listen 80;
    listen [::]:80;
    server_name www.agilitycourses.com agilitycourses.com;

    # letsencrypt location
    location ^~ /.well-known/ {
        allow all;
        root /usr/share/nginx/html/;
    }
    location / {
        return 301 https://www.agilitycourses.com$request_uri;
    }
}

# redirect https://tld to https://www.tld
server {
    listen 443 ssl;
    listen [::]:443 ipv6only=on ssl;

    server_name agilitycourses.com;
    # certificates are needed here too
    ssl_certificate /etc/letsencrypt/live/agilitycourses.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/agilitycourses.com/privkey.pem;
    return 301 https://www.agilitycourses.com$request_uri;
}

server {
    listen 443 ssl;
    listen [::]:443 ssl;

    server_name www.agilitycourses.com;
    root /home/agilitycourses/production/current/;

    ssl_certificate /etc/letsencrypt/live/agilitycourses.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/agilitycourses.com/privkey.pem;

    include /etc/nginx/ssl.conf;
    include /etc/nginx/security_headers.conf;
    ...
}
&lt;/pre&gt;
&lt;p&gt;So now I have an &amp;quot;A&amp;quot; score from &lt;cite&gt;securityheaders.io&lt;/cite&gt;&lt;/p&gt;
&lt;ol class="arabic" start="5"&gt;
&lt;li&gt;&lt;p class="first"&gt;The Digital Ocean tutorial sets up a root crontab entry to automatically update the SSL Certificate. I decided to also update the letsencrypt client software automatically:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# m h  dom mon dow   command
20 2 * * 1 cd /opt/letsencrypt &amp;amp;&amp;amp; git pull
30 2 * * 1 /opt/letsencrypt/letsencrypt-auto renew &amp;gt;&amp;gt; /var/log/le-renew.log
35 2 * * 1 /etc/init.d/nginx reload
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The last change I made was to pass along the presence/absence of HTTPS from NGINX to Gunicorn/Django via the &lt;cite&gt;X-Forwarded-Proto&lt;/cite&gt; header as &lt;a class="reference external" href="https://docs.djangoproject.com/en/1.10/topics/security/#ssl-https"&gt;described in the Django SSL/HTTPS docs&lt;/a&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
location &amp;#64;proxy-to-app {
    proxy_pass http://agilitycourses-production-gunicorn;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Accept-Encoding &amp;quot;&amp;quot;;
    proxy_read_timeout 120;
    proxy_send_timeout 120;
    ...
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Based on the Django recommendations I also made these changes in my &lt;cite&gt;settings.py&lt;/cite&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# SSL settings
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SECURE_BROWSER_XSS_FILTER = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Even with a lot of web browsing to learn about these settings the whole process only took a couple hours.
Now that I've done it once (and updated my Fabric fabfile.py) it will be easier to convert my other domains.&lt;/p&gt;
</summary><category term="nginx"></category><category term="ubuntu"></category><category term="https"></category><category term="ssl"></category><category term="django"></category><category term="gunicorn"></category><category term="letsencrypt"></category></entry><entry><title>NGINX CGI Parameter Gotcha</title><link href="http://tech.agilitynerd.com/nginx-cgi-parameter-gotcha.html" rel="alternate"></link><published>2016-07-31T12:02:00-05:00</published><author><name>Steve Schwarz</name></author><id>tag:tech.agilitynerd.com,2016-07-31:nginx-cgi-parameter-gotcha.html</id><summary type="html">&lt;p&gt;When I first started the &lt;a class="reference external" href="http://agilitynerd.com"&gt;agilitynerd&lt;/a&gt;  blog in 2004 I had my &lt;a class="reference external" href="http://blosxom.sourceforge.net/"&gt;Blosxom&lt;/a&gt; blogging CGI script running via &lt;a class="reference external" href="http://httpd.apache.org/"&gt;Apache&lt;/a&gt;. Later on I moved all my sites to &lt;a class="reference external" href="https://nginx.org/en/"&gt;nginx&lt;/a&gt; or took advantage of nginx's caching features to have it act as a proxy in front of Apache. I finally decided to remove Apache entirely and that meant solving running CGI scripts using nginx.&lt;/p&gt;
&lt;p&gt;After some googling I found FastCGI and &lt;a class="reference external" href="https://www.nginx.com/resources/wiki/start/topics/examples/fcgiwrap/"&gt;fcgiwrap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I'm on Ubuntu so installation was as easy as:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get install fcgiwrap
&lt;/pre&gt;
&lt;p&gt;That setup the init script that starts the fcgi daemon. To run the cgi script(s) nginx has to be configured to parse apart the incoming URL, execute the appropriate script and pass along any arguments needed by the CGI script. Sounds easy.&lt;/p&gt;
&lt;p&gt;I only want to support running a single CGI script: &lt;tt class="docutils literal"&gt;index.cgi&lt;/tt&gt; and pass along the path after the root of URL as the argument to the script. Most examples are more generic and parse out any cgi script and any arguments.&lt;/p&gt;
&lt;p&gt;The key built-in to nginx to do the splitting is &lt;tt class="docutils literal"&gt;fastcgi_split_path_info&lt;/tt&gt; which takes a regex with two captured groups to parse out the script name and the arguments. These are stored in the &lt;tt class="docutils literal"&gt;$fastcgi_script_name&lt;/tt&gt; and the &lt;tt class="docutils literal"&gt;$fastcgi_path_info&lt;/tt&gt; variables respectively. This &lt;a class="reference external" href="https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx"&gt;Digital Ocean article&lt;/a&gt; discusses FastCGI and has an excellent discussion of the variables available and also used by &lt;tt class="docutils literal"&gt;fcgiwrap&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;So I created this configuration file that matches &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://agilitynerd.com/blog/foo.html&lt;/span&gt;&lt;/tt&gt; and invokes &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/home/agilitynerd/cgi-bin/index.cgi&lt;/span&gt; foo.html&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
location /blog/ {
    root /home/agilitynerd/cgi-bin/;

    fastcgi_split_path_info ^(/blog)(.*)$;
    include /etc/nginx/fastcgi_params;
    fastcgi_param DOCUMENT_ROOT /home/agilitynerd/cgi-bin/;
    fastcgi_param SCRIPT_NAME index.cgi$fastcgi_path_info;

    # Fastcgi socket
    fastcgi_pass  unix:/var/run/fcgiwrap.socket;
}
&lt;/pre&gt;
&lt;p&gt;You'll notice: &lt;tt class="docutils literal"&gt;include /etc/nginx/fastcgi_params&lt;/tt&gt; is used to get default values for the &lt;tt class="docutils literal"&gt;fastcgi_param&lt;/tt&gt; variables.&lt;/p&gt;
&lt;p&gt;And it didn't work. I kept getting errors:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Cannot get script name, are DOCUMENT_ROOT and SCRIPT_NAME (or SCRIPT_FILENAME) set and is the script executable?&amp;quot;
&lt;/pre&gt;
&lt;p&gt;Clearly I'm setting &lt;tt class="docutils literal"&gt;DOCUMENT_ROOT&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;SCRIPT_NAME&lt;/tt&gt;. After almost a day of googling and testing (during which I found this helpful article on &lt;a class="reference external" href="https://blog.martinfjordvald.com/2013/06/debugging-nginx-errors/"&gt;nginx debugging&lt;/a&gt;) I temporarily commented out &lt;tt class="docutils literal"&gt;fastcgi_pass&lt;/tt&gt;, and returned the variables.&lt;/p&gt;
&lt;p&gt;I found that they were being set as I expected... Strange!&lt;/p&gt;
&lt;p&gt;Then I came across this &lt;a class="reference external" href="https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx"&gt;Digital Ocean article&lt;/a&gt; where they have a critical discussion on overriding variables in which they state:&lt;/p&gt;
&lt;blockquote&gt;
This inconsistency and unpredictability means that you cannot and should not rely on the backend to correctly interpret your intentions when setting the same parameter more than one time. The only safe solution is to only declare each parameter once. This also means that there is no such thing as safely overriding a default value with the fastcgi_param directive.&lt;/blockquote&gt;
&lt;p&gt;So in my case I commented out &lt;tt class="docutils literal"&gt;DOCUMENT_ROOT&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;SCRIPT_FILENAME&lt;/tt&gt; in the &lt;tt class="docutils literal"&gt;/etc/nginx/fastcgi_params&lt;/tt&gt; file, reloaded nginx, and voila! Everything worked. Hope this helps you if you run in to the same problem.&lt;/p&gt;
</summary><category term="nginx"></category><category term="cgi"></category><category term="fcgiwrap"></category><category term="ubuntu"></category><category term="apache"></category></entry></feed>